// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Tea_Cmd from "rescript-tea/src/Tea_Cmd.res.mjs";
import * as Core__JSON from "@rescript/core/src/Core__JSON.res.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as Core__Promise from "@rescript/core/src/Core__Promise.res.mjs";

let vql_aliases = [
  "verisimdb",
  "verisim"
];

let vql_keywords = [
  "SELECT",
  "FROM",
  "WHERE",
  "LIMIT",
  "INSERT",
  "INTO",
  "VALUES",
  "DELETE",
  "SEARCH",
  "TEXT",
  "VECTOR",
  "RELATED",
  "BY",
  "SHOW",
  "STATUS",
  "DRIFT",
  "NORMALIZER",
  "HEXADS",
  "COUNT",
  "EXPLAIN",
  "GRAPH",
  "TENSOR",
  "SEMANTIC",
  "DOCUMENT",
  "TEMPORAL",
  "HEXAD",
  "PROOF",
  "WITNESS",
  "VERIFY"
];

let vql = {
  id: "vql",
  displayName: "VeriSimDB",
  languageName: "VQL",
  description: "6-core multimodal database with self-normalization",
  aliases: vql_aliases,
  defaultHost: "localhost",
  defaultPort: 8080,
  executePath: "/vql/execute",
  healthPath: "/health",
  prompt: "vql> ",
  supportsDt: true,
  keywords: vql_keywords
};

let gql_aliases = [
  "lithoglyph",
  "formdb"
];

let gql_keywords = [
  "MATCH",
  "CREATE",
  "DELETE",
  "SET",
  "RETURN",
  "WHERE",
  "AND",
  "OR",
  "NOT",
  "WITH",
  "UNWIND",
  "ORDER",
  "BY",
  "LIMIT",
  "SKIP",
  "VERTEX",
  "EDGE",
  "PATH",
  "SHORTEST",
  "PATTERN",
  "PROPERTIES",
  "LABELS",
  "PROOF",
  "WITNESS",
  "VERIFY",
  "MORPHISM",
  "FUNCTOR"
];

let gql = {
  id: "gql",
  displayName: "Lithoglyph",
  languageName: "GQL",
  description: "Graph database with formal verification",
  aliases: gql_aliases,
  defaultHost: "localhost",
  defaultPort: 8081,
  executePath: "/gql/execute",
  healthPath: "/health",
  prompt: "gql> ",
  supportsDt: true,
  keywords: gql_keywords
};

let kql_aliases = [
  "quandledb",
  "quandle"
];

let kql_keywords = [
  "DEFORM",
  "CLASSIFY",
  "CONNECT",
  "DISTINGUISH",
  "TRANSFORM",
  "WITNESS",
  "UNDER",
  "REIDEMEISTER",
  "ISOTOPY",
  "INVARIANT",
  "CROSSING",
  "KNOT",
  "LINK",
  "BRAID",
  "QUANDLE",
  "RACK",
  "JONES",
  "ALEXANDER",
  "HOMFLY",
  "BRACKET",
  "WRITHE",
  "PROOF",
  "VERIFY",
  "EQUIVALENT"
];

let kql = {
  id: "kql",
  displayName: "QuandleDB",
  languageName: "KQL",
  description: "Knot-theoretic structural equivalence database",
  aliases: kql_aliases,
  defaultHost: "localhost",
  defaultPort: 8082,
  executePath: "/kql/execute",
  healthPath: "/health",
  prompt: "kql> ",
  supportsDt: true,
  keywords: kql_keywords
};

let builtins = [
  vql,
  gql,
  kql
];

let customs = {
  contents: []
};

function all() {
  return builtins.concat(customs.contents);
}

function decodeProfile(json) {
  let dict = Core__JSON.Classify.classify(json);
  if (typeof dict !== "object") {
    return;
  }
  if (dict.TAG !== "Object") {
    return;
  }
  let dict$1 = dict._0;
  let getString = key => {
    let v = dict$1[key];
    if (v === undefined) {
      return;
    }
    let s = Core__JSON.Classify.classify(v);
    if (typeof s !== "object" || s.TAG !== "String") {
      return;
    } else {
      return s._0;
    }
  };
  let getInt = key => {
    let v = dict$1[key];
    if (v === undefined) {
      return;
    }
    let n = Core__JSON.Classify.classify(v);
    if (typeof n !== "object" || n.TAG !== "Number") {
      return;
    } else {
      return n._0 | 0;
    }
  };
  let getBool = key => {
    let v = dict$1[key];
    if (v === undefined) {
      return false;
    }
    let b = Core__JSON.Classify.classify(v);
    if (typeof b !== "object" || b.TAG !== "Bool") {
      return false;
    } else {
      return b._0;
    }
  };
  let getStringArray = key => {
    let v = dict$1[key];
    if (v === undefined) {
      return [];
    }
    let arr = Core__JSON.Classify.classify(v);
    if (typeof arr !== "object") {
      return [];
    } else if (arr.TAG === "Array") {
      return Core__Array.filterMap(arr._0, item => {
        let s = Core__JSON.Classify.classify(item);
        if (typeof s !== "object" || s.TAG !== "String") {
          return;
        } else {
          return s._0;
        }
      });
    } else {
      return [];
    }
  };
  let match = getString("id");
  let match$1 = getString("displayName");
  let match$2 = getString("languageName");
  let match$3 = getString("description");
  let match$4 = getInt("defaultPort");
  let match$5 = getString("executePath");
  let match$6 = getString("healthPath");
  let match$7 = getString("prompt");
  if (match !== undefined && match$1 !== undefined && match$2 !== undefined && match$3 !== undefined && match$4 !== undefined && match$5 !== undefined && match$6 !== undefined && match$7 !== undefined) {
    return {
      id: match,
      displayName: match$1,
      languageName: match$2,
      description: match$3,
      aliases: getStringArray("aliases"),
      defaultHost: Core__Option.getOr(getString("defaultHost"), "localhost"),
      defaultPort: match$4,
      executePath: match$5,
      healthPath: match$6,
      prompt: match$7,
      supportsDt: getBool("supportsDt"),
      keywords: getStringArray("keywords")
    };
  }
}

function decodeProfiles(json) {
  let arr = Core__JSON.Classify.classify(json);
  if (typeof arr !== "object") {
    return [];
  } else if (arr.TAG === "Array") {
    return Core__Array.filterMap(arr._0, decodeProfile);
  } else {
    return [];
  }
}

let FetchResponse = {};

function loadCustomProfiles() {
  return Tea_Cmd.effect(_dispatch => {
    Core__Promise.$$catch(fetch("/nqc-profiles.json").then(response => {
      if (response.ok) {
        return response.json();
      } else {
        return Promise.resolve([]);
      }
    }).then(json => {
      let profiles = decodeProfiles(json);
      if (profiles.length > 0) {
        customs.contents = profiles;
        console.log("NQC: Loaded", profiles.length.toString() + ` custom database profile(s)`);
      }
      return Promise.resolve();
    }), param => Promise.resolve());
  });
}

function findById(targetId) {
  let lower = targetId.toLowerCase();
  return builtins.concat(customs.contents).find(p => {
    if (p.id === lower) {
      return true;
    } else {
      return p.aliases.some(a => a.toLowerCase() === lower);
    }
  });
}

export {
  vql,
  gql,
  kql,
  builtins,
  customs,
  all,
  decodeProfile,
  decodeProfiles,
  FetchResponse,
  loadCustomProfiles,
  findById,
}
/* No side effect */
