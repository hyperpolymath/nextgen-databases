// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Int from "@rescript/core/src/Core__Int.res.mjs";
import * as Core__JSON from "@rescript/core/src/Core__JSON.res.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

function extractRows(json) {
  let asArrayOr = (value, fallback) => {
    let arr = Core__JSON.Classify.classify(value);
    if (typeof arr !== "object" || arr.TAG !== "Array") {
      return fallback;
    } else {
      return arr._0;
    }
  };
  let arr = Core__JSON.Classify.classify(json);
  if (typeof arr !== "object") {
    return [json];
  }
  switch (arr.TAG) {
    case "Object" :
      let dict = arr._0;
      let rows = dict["rows"];
      if (rows !== undefined) {
        return asArrayOr(rows, [json]);
      }
      let data = dict["data"];
      if (data !== undefined) {
        return asArrayOr(data, [json]);
      }
      let results = dict["results"];
      if (results !== undefined) {
        return asArrayOr(results, [json]);
      } else {
        return [json];
      }
    case "Array" :
      return arr._0;
    default:
      return [json];
  }
}

function extractColumns(rows) {
  let firstRow = rows[0];
  if (firstRow === undefined) {
    return [];
  }
  let dict = Core__JSON.Classify.classify(firstRow);
  if (typeof dict !== "object") {
    return ["value"];
  }
  switch (dict.TAG) {
    case "Object" :
      return Object.keys(dict._0);
    case "Array" :
      return Core__Array.fromInitializer(dict._0.length, i => i.toString());
    default:
      return ["value"];
  }
}

function jsonToString(v) {
  let s = Core__JSON.Classify.classify(v);
  if (typeof s !== "object") {
    return "null";
  }
  switch (s.TAG) {
    case "Bool" :
      if (s._0) {
        return "true";
      } else {
        return "false";
      }
    case "String" :
      return s._0;
    case "Number" :
      return s._0.toString();
    case "Object" :
    case "Array" :
      return JSON.stringify(v);
  }
}

function cellValue(row, column) {
  let dict = Core__JSON.Classify.classify(row);
  if (typeof dict !== "object") {
    return "null";
  }
  switch (dict.TAG) {
    case "Bool" :
      if (dict._0) {
        return "true";
      } else {
        return "false";
      }
    case "String" :
      return dict._0;
    case "Number" :
      return dict._0.toString();
    case "Object" :
      let v = dict._0[column];
      if (v !== undefined) {
        return jsonToString(v);
      } else {
        return "";
      }
    case "Array" :
      let idx = Core__Int.fromString(column, undefined);
      if (idx === undefined) {
        return "";
      }
      let v$1 = dict._0[idx];
      if (v$1 !== undefined) {
        return jsonToString(v$1);
      } else {
        return "";
      }
  }
}

function renderTable(json) {
  let rows = extractRows(json);
  let columns = extractColumns(rows);
  if (rows.length === 0) {
    return JsxRuntime.jsx("div", {
      children: "Query returned no results.",
      className: "nqc-results__empty"
    });
  } else {
    return JsxRuntime.jsxs("table", {
      children: [
        JsxRuntime.jsx("thead", {
          children: JsxRuntime.jsx("tr", {
            children: columns.map(col => JsxRuntime.jsx("th", {
              children: col
            }, col))
          })
        }),
        JsxRuntime.jsx("tbody", {
          children: rows.map((row, rowIdx) => JsxRuntime.jsx("tr", {
            children: columns.map(col => JsxRuntime.jsx("td", {
              children: cellValue(row, col)
            }, col))
          }, rowIdx.toString()))
        })
      ],
      className: "nqc-results__table"
    });
  }
}

function renderJson(json) {
  let formatted;
  try {
    formatted = JSON.stringify(json, undefined, 2);
  } catch (exn) {
    formatted = "Failed to format JSON";
  }
  return JsxRuntime.jsx("pre", {
    children: formatted,
    className: "nqc-results__pre"
  });
}

function renderCsv(json) {
  let rows = extractRows(json);
  let columns = extractColumns(rows);
  let escapeCell = value => {
    if (value.includes(",") || value.includes("\"") || value.includes("\n")) {
      return "\"" + value.replaceAll("\"", "\"\"") + "\"";
    } else {
      return value;
    }
  };
  let headerLine = columns.map(escapeCell).join(",");
  let dataLines = rows.map(row => columns.map(col => escapeCell(cellValue(row, col))).join(","));
  let csvText = [headerLine].concat(dataLines).join("\n");
  return JsxRuntime.jsx("pre", {
    children: csvText,
    className: "nqc-results__pre"
  });
}

function make(results, format) {
  if (results === undefined) {
    return JsxRuntime.jsxs("div", {
      children: [
        JsxRuntime.jsx("div", {
          children: "No results yet."
        }),
        JsxRuntime.jsx("div", {
          children: "Write a query above and press Ctrl+Enter to execute.",
          style: {
            fontSize: "13px",
            marginTop: "8px"
          }
        })
      ],
      className: "nqc-results__empty"
    });
  }
  switch (format) {
    case "Table" :
      return renderTable(results);
    case "Json" :
      return renderJson(results);
    case "Csv" :
      return renderCsv(results);
  }
}

export {
  extractRows,
  extractColumns,
  jsonToString,
  cellValue,
  renderTable,
  renderJson,
  renderCsv,
  make,
}
/* react/jsx-runtime Not a pure module */
